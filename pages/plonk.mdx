import { Callout } from "nextra/components"

## Why use cryptography?
    ### Decentralized system

> Decentralized systems: where the answer to
'Who’s responsible for this mess?' is 'Everyone
and no one at the same time.

In the traditional system, banks and money exchangers
are tasked with managing users' assets. When you
make a deposit, your funds become the property 
of the bank. The bank emits a "I Owe You" (IOU)
that is essentially a debt to you. After, it is
allowed to use your funds in many ways it sees fit.

Many customers are under the impression that the bank
*keeps* their funds in a vault somewhere and that 
they can come back and withdraw them at any time.
This is not true at all. Only a small fraction is
available to cover the *estimated* amount of withdrawals
from daily customers. When too many people decide
to take their money out at the same time, the bank
runs out of cash.

Decentralized systems are designed to block a
single party from having the ability to operate on
your funds.

In decentralized system, computers running the
node software agree on a set of hard rules (consensus).
If a node attempts to deviate from the consensus,
the system will reject it.

<Callout>
Imagine a government where every decision has to be 
approved by the majority of politicians. Every 
politician is a robot that follows the same program.
</Callout>

Obviously, it is critical that the program is bug-free
since all the nodes follow the same program.

But the system is resilient to attacks once the majority
is large enough. If a malicious node tries to suggest
to deviate from the rules, it will be automatically voted
out.

    ### Identity: What makes me special?
> Muffin: "I don't have to, aunt Chili, I'm special."

When you remove the central authority in charge of maintaining
customers and accounts, you have a new challenge.

How does the system recognize that someone is the *owner*
of funds and that he is authorized to spend but not other people?

There must be a way to differentiate users without requiring them
to register in a central database.

<Callout>
Cryptocurrencies use Cryptography. Cryptography use numbers.
</Callout>

    ### Integers and Finite Field
> 0, 1, 2, are ok. 0x0c5321e71fea98112607e1b6a2935ab346697d0f98e208561ed2ad0bb831217b
is cooler.

All the numbers that cryptography use are integers. We
will not see $\pi$ or $\sqrt{2}$, just integers like 0, 1, 2, etc.

It is not that limitating since there is an infinity of them.
In fact, there is *too many* of them. No real device can store
an infinite number! 

We'll deal with integers in a limited range: from 0 to p-1, where
p is a sufficiently large number. Typically, p has around 256 bits.
That gives us room for about $10^{77}$ different numbers.

<Callout>
$2^{256}$ is an extremely large number. To give a sense 
of its magnitude, consider that $2^{256}$ grains of sand
will take the volume 2 million galaxies the size of the Milky
Way.
</Callout>

    ### Secrets

Numbers[^1] serves as the proof of identity. If you 
randomly pick a number as your **SECRET**
the odds that you choose the same
number as someone else is astronomically low. It would
like choosing the same grain of sand in a million galaxies.
Of course, this assumes that you really *randomly* pick
the number. From experience, humans are *very* bad at
making random decisions. Given a large range, they will
likely favor the lower part or the higher part. It is also
why passwords tend to repeat.

<Callout>
Always use a random number generator. Don't try
to pick it yourself.
</Callout>

And don't try to remember the secret because one day
you will forget and your funds will be *LOST*.

    ### Hash Functions
> Back when PHP had less than 100 functions
and the function hashing mechanism was strlen()...

These secret numbers are extremely important because
1. you need them to spend your funds;
1. anyone who knows them can spend your funds.

You should keep them in a safe place and make sure
that others cannot get access without your permission.

But then, how can you use them more than once?

After all, when you show your identification card
to the bank teller, he sees it and theorically could
make a copy. In practice that's not feasible because
of the security measures like the hologram or the
special paper but a cryptographic secret is just
a number. Numbers can be copied in a fraction of second.

<Callout type="warning">
If you input your secret into some malware, it can
be copied before you can realize it.
</Callout>

Therefore we need a way to prove that you have the
secret *without* actually showing it!

<Callout>
The system does not care what your secret is.
The only thing that matters is that you know what it is.
</Callout>

    ### Commitments
> Why did the cryptographic commitment go to therapy? Because
it had trust issues and couldn’t open up!

    ### Statements
> "Logic is the beginning of wisdom, not the end." – Spock, "Star Trek VI: The Undiscovered Country"

    ### ZKP
> Zero-knowledge proofs: because sometimes proving you know something without saying anything is the best way to win an argument.

### Footnotes

[^1]: More precisely field elements since they are integers
that belong to a finite field.


## Sudoku
    ### Secrets
    ### Statement
## ZKP Step 1: Arithmetization
    ### Gates and Wires
    ### Constraint System
    ### Row Constraints
    ### Copy Wires
    ### Permutation Constraints
## ZKP Step 2: Polynomials
    ### Transformation to Polynomials
    ### Accumulator
    ### Polynomial Commitment
    ### Blind Evaluation
    ### Kate Commitments
    ### Inner Proof Arguments
## Verification
